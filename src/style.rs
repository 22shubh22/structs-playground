
#[allow(non_camel_case_types, non_snake_case, non_upper_case_globals, unused)]
pub mod bindings {
    include!(concat!(env!("OUT_DIR"), "/bindings.rs"));
}

pub trait ToComputedValue {
    type ComputedValue;
    fn to_computed_value(&self) -> Self::ComputedValue;
}

pub mod values {
    pub mod computed {
        use cssparser::RGBA;

        pub type Color = RGBA;
    }

    pub mod specified {
        use cssparser::RGBA;
        use style::values::computed;
        use style::ToComputedValue;

        #[allow(unused)]
        pub enum Color {
            CurrentColor,
            Numeric(RGBA),
        }

        impl ToComputedValue for Color {
            type ComputedValue = computed::Color;

            fn to_computed_value(&self) -> RGBA {
                match *self {
                    // This is really the parent style, but...
                    Color::CurrentColor => RGBA::new(0, 0, 0, 0),
                    Color::Numeric(c) => c,
                }
            }
        }
    }
}

pub mod conversions {
    use cssparser::RGBA;
    use style::bindings::nscolor;

    pub fn convert_color_to_nscolor(color: RGBA) -> nscolor {
        (color.red as u32) << 24 |
        (color.green as u32) << 16 |
        (color.blue as u32) << 8 |
        color.alpha as u32
    }
}

pub mod properties {
    use cssparser::RGBA;
    use style::bindings;
    use style::{conversions, values, ToComputedValue};

    // This struct is autogenerated in Rust, but...
    #[repr(C)]
    pub struct Style {
        // Uses the C++ structs!
        pub color: Box<bindings::StyleColor>,
    }

    pub fn compute_a_style() -> Box<Style> {
        let color_from_stylesheet =
            values::specified::Color::Numeric(RGBA::new(0, 0, 0, 255));

        let color = Box::new(bindings::StyleColor {
            m_color: conversions::convert_color_to_nscolor(color_from_stylesheet.to_computed_value()),
        });

        Box::new(Style { color })
    }
}
