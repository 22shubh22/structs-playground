use cssparser::RGBA;

#[allow(non_camel_case_types, non_snake_case, non_upper_case_globals, unused)]
pub mod bindings {
    include!(concat!(env!("OUT_DIR"), "/bindings.rs"));
}

pub struct Context {
    pub writing_mode_is_rtl: bool,
    pub parent_color: RGBA,
}

pub trait ToComputedValue {
    type ComputedValue;
    fn to_computed_value(&self, context: &Context) -> Self::ComputedValue;
}

pub mod values {
    pub mod computed {
        use cssparser::RGBA;

        pub type Color = RGBA;

        #[allow(unused)]
        pub enum Float {
            None,
            Left,
            Right,
        }
    }

    pub mod specified {
        use cssparser::RGBA;
        use style::values::computed;
        use style::{ToComputedValue, Context};

        #[allow(unused)]
        pub enum Color {
            CurrentColor,
            Numeric(RGBA),
        }

        impl ToComputedValue for Color {
            type ComputedValue = computed::Color;

            fn to_computed_value(&self, context: &Context) -> RGBA {
                match *self {
                    Color::CurrentColor => context.parent_color,
                    Color::Numeric(c) => c,
                }
            }
        }

        #[allow(unused)]
        pub enum Float {
            None,
            Left,
            Right,
            InlineEnd,
            InlineStart,
        }

        impl ToComputedValue for Float {
            type ComputedValue = computed::Float;

            fn to_computed_value(&self, context: &Context) -> Self::ComputedValue {
                match *self {
                    Float::None => computed::Float::None,
                    Float::Left => computed::Float::Left,
                    Float::Right => computed::Float::Right,
                    Float::InlineStart => {
                        if context.writing_mode_is_rtl {
                            computed::Float::Right
                        } else {
                            computed::Float::Left
                        }
                    }
                    Float::InlineEnd => {
                        if context.writing_mode_is_rtl {
                            computed::Float::Left
                        } else {
                            computed::Float::Right
                        }
                    }
                }
            }
        }
    }
}

pub mod conversions {
    use cssparser::RGBA;
    use style::bindings;
    use style::values::computed::Float as ComputedFloat;

    pub fn convert_color_to_nscolor(color: RGBA) -> bindings::nscolor {
        (color.red as u32) << 24 |
        (color.green as u32) << 16 |
        (color.blue as u32) << 8 |
        color.alpha as u32
    }

    pub fn convert_float(float: ComputedFloat) -> bindings::StyleFloat {
        match float {
            ComputedFloat::None => bindings::StyleFloat::None,
            ComputedFloat::Left => bindings::StyleFloat::Left,
            ComputedFloat::Right => bindings::StyleFloat::Right,
        }
    }
}

pub mod properties {
    use cssparser::RGBA;
    use style::{bindings, Context};
    use style::{conversions, values, ToComputedValue};

    // This struct is autogenerated in Rust, but...
    #[repr(C)]
    pub struct Style {
        // Uses the C++ structs!
        pub color: Box<bindings::StyleColor>,
        pub display: Box<bindings::StyleDisplay>,
    }

    pub fn compute_a_style() -> Box<Style> {
        let color_from_stylesheet =
            values::specified::Color::Numeric(RGBA::new(0, 0, 0, 255));

        let float_from_stylesheet =
            values::specified::Float::InlineEnd;

        let context = Context {
            writing_mode_is_rtl: false,
            parent_color: RGBA::transparent(),
        };

        let computed_color = color_from_stylesheet.to_computed_value(&context);
        let color = Box::new(bindings::StyleColor {
            m_color: conversions::convert_color_to_nscolor(computed_color),
        });

        let computed_float = float_from_stylesheet.to_computed_value(&context);
        let display = Box::new(bindings::StyleDisplay {
            m_float: conversions::convert_float(computed_float),
        });

        Box::new(Style { color, display })
    }
}
